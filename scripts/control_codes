#!/usr/bin/perl -w

use utf8;
use autodie;

use Modern::Perl;
use Getopt::Long;
use File::Slurp;

# Command line options
my $help;
my $dest;
my $verbose;
my $debug;

GetOptions(
    'help|h' => \$help,
    'destination|d=s' => \$dest,
    'verbose|v' => \$verbose,
    'debug' => \$debug,
);

$dest = "code_output" if !$dest;
my $src = $ARGV[0];

if ($help || !$src) {
    say "Convert control code comments to actual control code.";
    exit;
}

# Ouput format
my $h = "IR ADR1 ADR2 OP M1 M2 mem1 mem2 mem3 mem_addr ALU1 ALU2 ALU buss PC uCount uPC  uPC_addr";
my $c = "0   00  00   0  00 00  00   00   00    000     00   0   000 000  00   00   000  00000000";

my %ALU = (
    load => "001",
    '+' => "010",
    '-' =>"011",
    '++' =>"100",
    '--' => "101",
);

my %buss = (
    PC => "000",
    OP => "001",
    M1 => "010",
    M2 => "011",
    AR1 => "100",
    FIFO => "101",
    IN => "110",
);

my %mem_addr = (
    PC => "000",
    buss => "001",
    AR1 => "010",
    AR2 => "011",
    ADR1 => "100",
    ADR2 => "101",
);

# For mem1 mem2 mem3
my %mem = (
    read => "01",
    write => "10",
);

my %mem_map = (
    OP => "mem1",
    M1 => "mem2",
    M2 => "mem3",
);

my %registers = (
    PC => {
        buss => "01",
        '++' => "10",
    },
    IR => {
        buss => "1",
    },
    ADR1 => {
        buss => "01",
        M1 => "10",
        AR1 => "11",
    },
    ADR2 => {
        buss => "01",
        M2 => "10",
        AR2 => "11",
    },
    ALU1 => {
        M1 => "00",
        buss => "01",
        M2 => "10",
    },
    ALU2 => {
        M1 => "0",
        M2 => "1",
    },
    OP => {
        buss => "0",
    },
    M1 => {
        buss => "01",
        AR1 => "10",
        AR2 => "11",
    },
    M2 => {
        buss => "01",
        AR1 => "10",
        AR2 => "11",
    },
    mem_addr => \%mem_addr,
);

# One word commands
my %single_cmd = (
    'PC++' => $registers{PC}->{'++'},
    'ALU++' => $ALU{'++'},
    'ALU--' => $ALU{'--'},
);

# Positions for our subsignals in the grand control scheme
my %positions;

# Calculate positions from output format
my @namechunks = split (/\s+/, trim($h));
my @codechunks = split (/\s+/, trim($c));

my $signallength = length (join "", @codechunks);
my $l = $signallength - 1;

for my $chunk (@codechunks) {
    my $r = $l - length ($chunk) + 1;

    my $name = shift @namechunks;

    say "$name has $r .. $l" if $debug;

    $positions{$name} = [$r .. $l];

    $l = $r - 1;
}

say "" if $debug;

# Reverse the positions (we're using strings 0 indexed to the left but vhdl uses bits reversed)
for my $key (keys %positions) {
    my @mod;

    for my $val (@{$positions{$key}}) {
        push (@mod, $signallength - $val - 1);
    }

    # Need to reverse here as otherwise we'll assign eg (43, 42) to something which will reverse our code
    $positions{$key} = [reverse @mod];
}

# Convenience function, take reference to list and a string
sub update {
    my ($signal, $pos, $what) = @_;

    @$signal[ @{$pos} ] = split (//, $what);
}

open my $in, '<', $src;
#open my $out, '>', $dest;

my $codeline = 0;

# Process and write
while (my $line = <$in>) {
    chomp $line;

    # Comments
    if ($line =~ /^;(.*)/) {
        # If we're in verbose, simply output comments
        if ($verbose) {
            say $line;
        }
        # Otherwise transform into vhdl comments
        else {
            say "-- $1";
        }
        next;
    }
    # Simply output empty lines
    elsif ($line =~ /^\s*$/) {
        say $line;
        next;
    }

    $codeline++;

    my @signal = ((0) x 44);
    my @comments;

    my $buss_used = 0;
    my $mem_addr_set = 0;
    my $mem_data_used = 0;

    for my $cmd (split /\s*,\s*/, $line)
    {
        # Grab single word commands eg PC++, ALU--
        if ($cmd =~ /^(\S+?)(\+{2}|-{2})$/) {
            my $reg = $1;

            my $val = $single_cmd{$cmd};
            if ($val) {
                update (\@signal, $positions{$reg}, $val);

                #say $cmd;
                push (@comments, $cmd);
            }
            else {
                push (@comments, "(? $cmd)");
            }
        }
        # dest -> src
        elsif ($cmd =~ /(\S+)\s*->\s*(\S+)/) {
            my ($src, $dest) = ($1, $2);

            # src -> buss
            if ($dest eq "buss" && exists $buss{$src}) {

                # Check for multiple usage of buss
                if ($buss_used) {
                    push (@comments, "(? buss used! $cmd)");
                    next;
                }

                $buss_used = 1;

                update (\@signal, $positions{$dest}, $buss{$src});
                push (@comments, $cmd);
                next;
            }
            # src -> mem(mem_addr) or src -> mem
            elsif ($dest =~ /mem
                             (?:        # Non matching group
                             \(
                               (\S+)    # address
                             \)
                             )?         # Not necessary
                             $          # Match until the end (it doesn't match mem_addr for example)
                            /x)
            {
                my $addr = $1 // "";

                # Can only update from dataregisters
                if (!exists $mem_map{$src}) {
                    push (@comments, "(? $cmd)");
                    next;
                }
                # Check memory adressing input as valid
                elsif ($addr && !exists $mem_addr{$addr}) {
                    push (@comments, "(? $cmd)");
                    next;
                }

                if ($addr) {
                    $mem_addr_set = 1;

                    # Update mem_addr
                    update (\@signal, $positions{mem_addr}, $mem_addr{$addr});
                }

                $mem_data_used = 1;

                # Set mem to write
                update (\@signal, $positions{$mem_map{$src}}, $mem{write});

                push (@comments, $cmd);
            }
            # mem(mem_addr) -> dest or mem -> src
            elsif ($src =~ /mem
                             (?:        # Non matching group
                             \(
                               (\S+)    # address
                             \)
                             )?         # Not necessary
                             $          # Match until the end (it doesn't match mem_addr for example)
                            /x)
            {
                my $addr = $1 // "";

                # Can only update to dataregisters
                if (!exists $mem_map{$dest}) {
                    push (@comments, "(? $cmd)");
                    next;
                }
                # Check memory adressing input as valid
                elsif ($addr && !exists $mem_addr{$addr}) {
                    push (@comments, "(? $cmd)");
                    next;
                }

                if ($addr) {
                    $mem_addr_set = 1;

                    # Update mem_addr
                    update (\@signal, $positions{mem_addr}, $mem_addr{$addr});
                }

                $mem_data_used = 1;

                # Set mem to read
                update (\@signal, $positions{$mem_map{$dest}}, $mem{read});

                push (@comments, $cmd);
            }
            # Check that the register exists
            elsif (!exists $registers{$dest}) {
                #say "$dest doesn't exist";
                push (@comments, "(? $cmd)");
                next;
            }
            # Handle direct
            elsif (exists $registers{$dest}->{$src}) {
                my $val = $registers{$dest}->{$src};

                update (\@signal, $positions{$dest}, $val);

                # load if ALU
                if ($src =~ /^ALU/) {
                    update (\@signal, $positions{ALU}, $val);
                }

                # Check if mem_addr will get set
                $mem_addr_set = 1 if $dest eq "mem_addr";

                push (@comments, $cmd);
            }
            # Try to route through buss
            elsif (exists $registers{$dest}->{buss}) {
                #say "Routing through buss";

                # Can we do src -> buss?
                if (exists $buss{$src}) {

                    # Check for multiple usage of buss
                    if ($buss_used) {
                        push (@comments, "(? buss used! $cmd)");
                        next;
                    }

                    $buss_used = 1;

                    # Update src -> buss
                    update (\@signal, $positions{buss}, $buss{$src});
                    #say "src -> buss";
                    #say "pos: " . join (",", @{$positions{buss}});
                    #say "val: " . $buss{$src};

                    # Update buss -> dest
                    update (\@signal, $positions{$dest}, $registers{$dest}->{buss});
                    #say "buss -> dest";
                    #say "pos: " . join (",", @{$positions{$dest}});
                    #say "val: " . $registers{$dest}->{buss};

                    # Check if mem_addr will get set
                    $mem_addr_set = 1 if $dest eq "mem_addr";

                    # Comment as src -> buss, buss -> dest
                    push (@comments, "$src -> buss");
                    push (@comments, "buss -> $dest");
                }
                else {
                    #say "Couldn't find src -> buss";
                    push (@comments, "(? $cmd)");
                }
            }
            else {
                #say "Couldn't find buss -> dest";
                push (@comments, "(? $cmd)");
            }
        }
        # var = l op r
        elsif ($cmd =~ /(\S+)            # Assigned variable
                        \s*=\s*
                        (\S+)            # left
                        \s+(\S)\s+       # op
                        (\S+)            # right
                       /x)
        {
            my ($res, $l, $op, $r) = ($1, $2, $3, $4);

            #say "$res = $l $op $r";
            push (@comments, "(? $cmd)");
        }
        # var = stuff eg uPC = 0, uCount = 0, uPC_addr = AB or 10101011 (will truncate/fill)
        elsif ($cmd =~ /(\S+)\s*=\s*(\S+)/) {
            my ($var, $res) = ($1, $2);

            #say "var = $var, res = $res";

            if ($var eq 'uPC_addr') {
                my $bin;

                if ($res =~ /^[01]+$/) {
                    $bin = $res;
                }
                elsif ($res =~ /^[0123456789ABCDEF]+$/i) {
                    $bin = hex2bin($res);
                }
                else {
                    push (@comments, "(? $cmd)");
                    next;
                }

                # Force to length 8
                if (length($bin) < 8) {
                    $bin = '0' x (8 - length($bin)) . $bin;
                }
                elsif (length($bin) > 8) {
                    # Truncate from the back so 00 1111 1111 -> 1111 1111
                    $bin = substr $bin, -8;
                }

                update (\@signal, $positions{$var}, $bin);

                push (@comments, $cmd);
            }
            else {
                push (@comments, $cmd);
            }
        }
        else {
            push (@comments, "(? $cmd)");
        }
    }

    # Add in error if we're using the memory but don't specify what to address
    if ($mem_data_used && !$mem_addr_set) {
        push (@comments, "! no mem_addr set !");
    }

    # Output verbose mode, for humans
    if ($verbose) {
        # Output verbose output, format lines like this with the occassional help header

        # Need to display this more than once
        if ($codeline == 1) {
            # Take into account line numbering
            say "    $h";
        }

        my $result = "";
        my $last = 0;
        my $signal = join ("", @signal);

        my @codechunks = split (/\s+/, $c);
        my @spacechunks = split (/\S+/, $c);

        # Remove if there's an opening space
        if ($c =~ /^\s/) {
            $result .= shift @spacechunks;
            shift @codechunks;
        }
        # Will split out an empty string space otherwise
        else {
            shift @spacechunks;
        }

        # Bundle a code string by alternating code/space
        for my $code (@codechunks) {
            my $l = length($code);
            my $sig = substr ($signal, $last, $l);

            $result .= $sig;

            my $space = shift @spacechunks;
            $result .= $space if $space;

            $last += $l;
        }

        my $hexline = sprintf ("%x", $codeline);
        $hexline = "0".$hexline if length ($hexline) < 2;

        say "$hexline  $result ; " . join (", ", @comments);
    }
    # Output for vhdl copy paste
    else {
        my $res = '"' . join ("", @signal) . '", -- ' . join (", ", @comments);
        say $res;
    }
}

sub hex2bin {
    my $h = shift;
    my $hlen = length($h);
    my $blen = $hlen * 4;
    return unpack("B$blen", pack("H$hlen", $h));
}

sub trim
{
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

