#!/usr/bin/perl -w

use utf8;
use autodie;

use Modern::Perl;
use Getopt::Long;
use File::Slurp;

# Command line options
my $help;
my $dest;
my $lines_until_header = 20;
my $verbose;
my $debug;

GetOptions(
    'help|h' => \$help,
    'destination|d=s' => \$dest,
    'header|h=i' => \$lines_until_header,
    'verbose|v' => \$verbose,
    'debug' => \$debug,
);

$dest = "code_output" if !$dest;
my $src = $ARGV[0];

if ($help || !$src) {
    say "Convert control code comments to actual control code.";
    exit;
}

# Ouput format
my $h = "IR ADR1 ADR2 OP M1 M2 mem1 mem2 mem3 mem_addr ALU1 ALU2 ALU buss PC uCount uPC  uPC_addr";
my $c = "0   00  00   0  00 00  00   00   00    000     00   0   000 000  00   00   000  00000000";

my %ALU = (
    load => "001",
    '+' => "010",
    '-' =>"011",
    '++' =>"100",
    '--' => "101",
);

my %buss = (
    PC => "000",
    OP => "001",
    M1 => "010",
    M2 => "011",
    AR1 => "100",
    FIFO => "101",
    IN => "110",
);

# For mem1 mem2 mem3
my %mem = (
    read => "01",
    write => "10",
);

my %mem_map = (
    OP => "mem1",
    M1 => "mem2",
    M2 => "mem3",
);

# Single value shorthands will be a shorthand for
# position: $position{<val>} value: $registers{<val>}->{<key>}
my %singles = (
    jmp => "uPC",
    jmpZ => "uPC",
);

my %registers = (
    uPC => {
        '++' => "000",
        op_addr => "001",
        A_addr => "010",
        B_addr => "011",
        jmp => "100",
        jmpZ => "101",
        '0' => "111",
    },
    uCount => {
        '++' => "00",
        Z => "01",
        '0' => "11",
    },
    PC => {
        buss => "01",
        '++' => "10",
    },
    IR => {
        buss => "1",
    },
    ADR1 => {
        buss => "01",
        M1 => "10",
        AR1 => "11",
    },
    ADR2 => {
        buss => "01",
        M2 => "10",
        AR2 => "11",
    },
    ALU1 => {
        M1 => "00",
        buss => "01",
        M2 => "10",
    },
    ALU2 => {
        M1 => "0",
        M2 => "1",
    },
    OP => {
        buss => "0",
    },
    M1 => {
        buss => "01",
        AR1 => "10",
        AR2 => "11",
    },
    M2 => {
        buss => "01",
        AR1 => "10",
        AR2 => "11",
    },
    mem_addr => {
        PC => "000",
        buss => "001",
        AR1 => "010",
        AR2 => "011",
        ADR1 => "100",
        ADR2 => "101",
    },
);

# Positions for our subsignals in the grand control scheme
my %positions;

# Calculate positions from output format
my @namechunks = split (/\s+/, trim($h));
my @codechunks = split (/\s+/, trim($c));

my $signallength = length (join "", @codechunks);
my $l = $signallength - 1;

for my $chunk (@codechunks) {
    my $r = $l - length ($chunk) + 1;

    my $name = shift @namechunks;

    say "$name has $r .. $l" if $debug;

    $positions{$name} = [$r .. $l];

    $l = $r - 1;
}

say "" if $debug;

# Reverse the positions (we're using strings 0 indexed to the left but vhdl uses bits reversed)
for my $key (keys %positions) {
    my @mod;

    for my $val (@{$positions{$key}}) {
        push (@mod, $signallength - $val - 1);
    }

    # Need to reverse here as otherwise we'll assign eg (43, 42) to something which will reverse our code
    $positions{$key} = [reverse @mod];
}

# Convenience function, take reference to list and a string
sub update {
    my ($signal, $pos, $what) = @_;

    @$signal[ @{$pos} ] = split (//, $what);
}

open my $in, '<', $src;
#open my $out, '>', $dest;

my $codeline = 0;
my $rows_since_help = 0;
my $last_was_code = 0;
my $header_shown = 0;

# Process and write
while (my $line = <$in>) {
    chomp $line;

    # Comments
    if ($line =~ /^;(.*)/) {
        # If we're in verbose, simply output comments
        if ($verbose) {
            say $line;
        }
        # Otherwise transform into vhdl comments
        else {
            say "-- $1";
        }
        $last_was_code = 0;
        next;
    }
    # Simply output empty lines
    elsif ($line =~ /^\s*$/) {
        say $line;
        $last_was_code = 0;
        next;
    }

    $codeline++;

    my @signal = ((0) x 44);
    my @comments;

    my $buss_used = 0;
    my $mem_addr_set = 0;
    my $mem_data_used = 0;
    my $alu_used = 0;

    for my $cmd (split /\s*,\s*/, $line)
    {
        # Grab single word affixes eg PC++, ALU--
        if ($cmd =~ /^(\S+?)(\+{2}|-{2})$/) {
            my ($reg, $op) = ($1, $2);

            #say "$reg $op";
            if (exists $registers{$reg}->{$op}) {
                update (\@signal, $positions{$reg}, $registers{$reg}->{$op});

                push (@comments, $cmd);
            }
            elsif ($reg eq "ALU") {
                $alu_used++;

                update (\@signal, $positions{$reg}, $ALU{$op});

                push (@comments, $cmd);
            }
            else {
                push (@comments, "(? $cmd)");
            }
        }
        # We have a single shorthand notation
        elsif (exists $singles{$cmd}) {
            my $reg = $singles{$cmd};

            $alu_used++ if $cmd =~ /^ALU/;

            update (\@signal, $positions{$reg}, $registers{$reg}->{$cmd});

            push (@comments, $cmd);
        }
        # dest -> src
        elsif ($cmd =~ /(\S+)\s*[=-]>\s*(\S+)/) {
            my ($src, $dest) = ($1, $2);

            # src -> buss
            if ($dest eq "buss" && exists $buss{$src}) {

                $buss_used++;

                update (\@signal, $positions{$dest}, $buss{$src});
                push (@comments, $cmd);
            }
            # src -> mem(mem_addr) or src -> mem
            elsif ($dest =~ /mem
                             (?:        # Non matching group
                             \(
                               (\S+)    # address
                             \)
                             )?         # Not necessary
                             $          # Match until the end (it doesn't match mem_addr for example)
                            /x)
            {
                my $addr = $1 // "";

                # Can only update from dataregisters
                if (!exists $mem_map{$src}) {
                    push (@comments, "? $cmd ?");
                    next;
                }
                # Check memory adressing input as valid
                elsif ($addr && !exists $registers{mem_addr}->{$addr}) {
                    push (@comments, "? $cmd ?");
                    next;
                }

                if ($addr) {
                    $mem_addr_set++;

                    # Update mem_addr
                    update (\@signal, $positions{mem_addr}, $registers{mem_addr}->{$addr});
                }

                $mem_data_used++;

                # Set mem to write
                update (\@signal, $positions{$mem_map{$src}}, $mem{write});

                push (@comments, $cmd);
            }
            # mem(mem_addr) -> dest or mem -> src
            elsif ($src =~ /mem
                             (?:        # Non matching group
                             \(
                               (\S+)    # address
                             \)
                             )?         # Not necessary
                             $          # Match until the end (it doesn't match mem_addr for example)
                            /x)
            {
                my $addr = $1 // "";

                # Can only update to dataregisters
                if (!exists $mem_map{$dest}) {
                    push (@comments, "? $cmd ?");
                    next;
                }
                # Check memory adressing input as valid
                elsif ($addr && !exists $registers{mem_addr}->{$addr}) {
                    push (@comments, "? $cmd ?");
                    next;
                }

                if ($addr) {
                    $mem_addr_set++;

                    # Update mem_addr
                    update (\@signal, $positions{mem_addr}, $registers{mem_addr}->{$addr});
                }

                $mem_data_used++;

                # Set mem to read
                update (\@signal, $positions{$mem_map{$dest}}, $mem{read});

                push (@comments, $cmd);
            }
            # Handle special assignments eg uCount -> Z
            elsif (exists $registers{$src}->{$dest}) {
                update (\@signal, $positions{$src}, $registers{$src}->{$dest});

                push (@comments, $cmd);
            }
            # Handle direct
            elsif (exists $registers{$dest}->{$src}) {
                update (\@signal, $positions{$dest}, $registers{$dest}->{$src});

                # load if ALU
                if ($dest =~ /^ALU/) {
                    update (\@signal, $positions{ALU}, $ALU{load});
                    $alu_used++;
                }

                $buss_used++ if $dest eq "buss";
                $mem_addr_set++ if $dest eq "mem_addr";

                push (@comments, $cmd);
            }
            # Try to route through buss
            elsif (exists $registers{$dest}->{buss} && exists $buss{$src}) {

                $buss_used++;

                # Update src -> buss
                update (\@signal, $positions{buss}, $buss{$src});

                # Update buss -> dest
                update (\@signal, $positions{$dest}, $registers{$dest}->{buss});

                # load if ALU
                if ($dest =~ /^ALU/) {
                    update (\@signal, $positions{ALU}, $ALU{load});
                    $alu_used++;
                }

                # Check if mem_addr will get set
                $mem_addr_set++ if $dest eq "mem_addr";

                # Comment as src -> buss, buss -> dest
                push (@comments, "$src -> buss");
                push (@comments, "buss -> $dest");
            }
            else {
                push (@comments, "? $cmd ?");
            }
        }
        # ALUx += src or ALUx -= src
        elsif ($cmd =~ /^(ALU[12])\s*(\+|-)=\s*(\S+)$/) {
            my ($alu, $op, $src) = ($1, $2, $3);

            # Check direct connection
            if (exists $registers{$alu}->{$src}) {

                $alu_used++;

                # Update data
                update (\@signal, $positions{$alu}, $registers{$alu}->{$src});

                # Update alu action
                update (\@signal, $positions{ALU}, $ALU{$op});

                push (@comments, $cmd);
            }
            # Try to route through buss
            elsif (exists $registers{$alu}->{buss} && exists $buss{$src}) {

                $buss_used++;
                $alu_used++;

                # Update src -> buss
                update (\@signal, $positions{buss}, $buss{$src});

                # Update buss -> alu
                update (\@signal, $positions{$alu}, $registers{$alu}->{buss});

                # load ALU
                update (\@signal, $positions{ALU}, $ALU{$op});

                push (@comments, $cmd);
            }
            else {
                push (@comments, "? $cmd ?");
            }
        }
        # var = stuff eg uPC = 0, uCount = 0, uPC_addr = AB or 10101011 (will truncate/fill)
        elsif ($cmd =~ /(\S+)\s*=\s*(\S+)/) {
            my ($var, $res) = ($1, $2);

            # Convert hex and stuff for addr jumping
            if ($var eq 'uPC_addr') {
                my $bin;

                if ($res =~ /^[01]+$/) {
                    $bin = $res;
                }
                elsif ($res =~ /^[0123456789ABCDEF]+$/i) {
                    $bin = hex2bin($res);
                }
                else {
                    push (@comments, "? $cmd ?");
                    next;
                }

                # Force to length 8
                if (length($bin) < 8) {
                    $bin = '0' x (8 - length($bin)) . $bin;
                }
                elsif (length($bin) > 8) {
                    # Truncate from the back so 00 1111 1111 -> 1111 1111
                    $bin = substr $bin, -8;
                }

                update (\@signal, $positions{$var}, $bin);

                push (@comments, $cmd);
            }
            # Check special eg uPC = 0
            elsif (exists $registers{$var} && exists $registers{$var}->{$res}) {
                update (\@signal, $positions{$var}, $registers{$var}->{$res});

                push (@comments, $cmd);
            }
            else {
                push (@comments, "? $cmd ?");
            }
        }
        else {
            push (@comments, "? $cmd ?");
        }
    }

    # Add in error if we're using the memory but don't specify what to address
    if ($mem_data_used && !$mem_addr_set) {
        push (@comments, "! no mem_addr !");
    }
    # Can only address all memory with one address at a time
    if ($mem_addr_set > 1) {
        push (@comments, "! 2x -> mem_addr !");
    }
    # Check that we're only using our buss once
    if ($buss_used > 1) {
        push (@comments, "! 2x -> buss !");
    }
    # Check only one operation for the alu
    if ($alu_used > 1) {
        push (@comments, "! 2x alu op !");
    }

    # Output verbose mode, for humans
    if ($verbose) {
        # Output verbose output, format lines like this with the occassional help header

        if (!$header_shown || $rows_since_help > $lines_until_header && !$last_was_code) {
            say "    $h";

            $header_shown = 1;
            $rows_since_help = 0;
        }

        $last_was_code = 1;
        $rows_since_help++;

        ##Need to display this more than once
        #if ($codeline == 1) {
            ##Take into account line numbering
            #say "    $h";
        #}

        my $result = "";
        my $last = 0;
        my $signal = join ("", @signal);

        my @codechunks = split (/\s+/, $c);
        my @spacechunks = split (/\S+/, $c);

        # Remove if there's an opening space
        if ($c =~ /^\s/) {
            $result .= shift @spacechunks;
            shift @codechunks;
        }
        # Will split out an empty string space otherwise
        else {
            shift @spacechunks;
        }

        # Bundle a code string by alternating code/space
        for my $code (@codechunks) {
            my $l = length($code);
            my $sig = substr ($signal, $last, $l);

            $result .= $sig;

            my $space = shift @spacechunks;
            $result .= $space if $space;

            $last += $l;
        }

        my $hexline = sprintf ("%x", $codeline);
        $hexline = "0".$hexline if length ($hexline) < 2;

        say "$hexline  $result ; " . join (", ", @comments);
    }
    # Output for vhdl copy paste
    else {
        my $res = '"' . join ("", @signal) . '", -- ' . join (", ", @comments);
        say $res;
    }
}

sub hex2bin {
    my $h = shift;
    my $hlen = length($h);
    my $blen = $hlen * 4;
    return unpack("B$blen", pack("H$hlen", $h));
}

sub trim
{
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

