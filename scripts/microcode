; Fetch instruction
        PC -> mem_addr, uCount = 0
        mem -> OP, mem -> M1, mem -> M2
        OP -> IR, jmp $AMOD

; Calculate adress mode for A operand
:AMOD   jmpAimm $BMOD               ; If immediate we're done
        M1 -> ALU1                  ; Address is a relative offset
        ALU1 += PC                  ; so add PC
        ALU1 -> M1
        jmpAdir $BMOD               ; If direct, we're done
        M1 -> mem_addr, mem -> M2   ; Check B address
        M2 -> M1                    ; Move it to A's place
        jmpApre $APRE               ; If pre-decr decr and come back
:AOFF   M1 -> ALU1                  ; Relative offset, add PC
        ALU1 += PC
        ALU1 -> M1
        jmp $BMOD                   ; Do the same for the B operand

:APRE   M1 -> ALU1                  ; Decr
        ALU--
        ALU1 -> M1, ALU1 -> M2
        M2 -> mem                   ; Write it back where it came from
        jmp $AOFF                   ; Continue

; Calculate adress mode for B operand
:BMOD   PC -> mem_addr              ; Retrieve data
        mem -> M2
        jmpBimm $INSTR              ; If immediate we're done
        M2 -> ALU1                  ; Relative address, add PC
        ALU1 += PC
        ALU1 -> M1
        jmpBdir $INSTR              ; If direct, we're done
        M2 -> mem_addr
        mem -> M2                   ; Check B operand of the address
        jmpBpre $BPRE
:BOFF   M2 -> ALU1                  ; Relative offset, add PC
        ALU1 += PC
        ALU1 -> M2
        jmp $INSTR                  ; We're done

:BPRE   M2 -> ALU1                  ; Decr
        ALU--
        ALU1 -> M2
        M2 -> mem                   ; Write it back where it came from
        jmp $BOFF                   ; Continue

; Execute instruction
;
; M1 (A operand) and M2 (B operand) contain either (should we move it to ADR1 and ADR2 instead?)
; Data if it's immediate
; Or absolute address to a memory location
;

:INSTR jmp $END

:END    PC++
:DELAY  jmpC 0                      ; Start over when we've spent enough time
        jmp $DELAY

; Examine A-field
; if immediate, we're done
; otherwise A-field += PC
; if direct, we're done
; otherwise the B-field of this direct memory location is read into the A-field
; if predecrement, then the value just read is decremented and written back
;   to the memory location from whence it came
;   A-field += PC
;
; do the same for the B-field...
; now examine and do code!
;
; finally, if no branch and instr not a DAT
; PC++ and insert into fifo
;
;
;   Direct (default)
; The value is an offset to the memory location.
;
; # Immediate
; The value is the data
;
; @ Indirect
; Offset to a memory location. B operand of that is an offset to another memory location.
;
; < Pre-decrement indirect
; Offset to a memory location. B operand there, B--, inserted again. That is then used as an offset to another memory location.

