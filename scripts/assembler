#!/usr/bin/perl -w

use utf8;
use autodie;

use Modern::Perl;
use Getopt::Long;

# Command line options
my $help;
my $dest;
my $verbose;
my $debug;

GetOptions(
    'help|h' => \$help,
    'destination|d=s' => \$dest,
    'verbose|v' => \$verbose,
    'debug' => \$debug,
);

# Not used atm
$dest = "code_output" if !$dest;
my $src = $ARGV[0];

if ($help || !$src) {
    say "Simple assembler";
    say "   options:";
    say "   -h --help       Show this screen.";
    say "   -v --verbose    Verbose output signals in a human readable format.";
    exit;
}

our %labels;
our %constants;

# Evaluate an operator statement, like val*2+1
sub evaluate {
    my ($def, $linenum) = @_;

    my @pieces = split /[-+*\/]/, $def;

    for my $piece (@pieces) {

        # Remove whitespace
        $piece = trim ($piece);

        # Ignore empty and all numbers
        next if $piece =~ /^\d*$/;

        # Read a label
        if ($piece =~ /^([A-Z0-9]{0,8})[A-Z0-9]*$/i) {
            my $label = $1;

            if (exists $labels{$label}) {

                # Substitute the label with it's value
                #$def =~ s/$piece/$labels{$label}/;

                # Addresses to labels are relative to the line of code
                my $relative = $labels{$label} - $linenum;
                $def =~ s/$piece/$relative/;
            }
            elsif (exists $constants{$label}) {

                # Substitute the label with it's value
                $def =~ s/$piece/$constants{$label}/;
            }
            else {
                die "Compile error, no label '$label' in scope.";
            }
        }
        else {
            die "Syntax error, label expected ner '$piece'";
        }
    }

    my $value = eval $def;
    die "Error: Malformed operator '$def' $@" if $@;

    return $value;
}

my $codeline = 0;

open my $in, '<', $src;

# Store line of code here when processing
my @code;

while (my $line = <$in>) {
    chomp $line;

    # Ignore empty lines
    next if $line =~ /^\s*$/;

    # Remove comments, will always match
    my ($code, $comment) = $line =~ /^([^;]*);?(.*)/;

    # Don't parse a full comment line
    next if !$code;

    # Match up a line of redcode
    if ($code =~ /^(?:
                      ([A-Z0-9]{0,8})?      # Label, not necessary
                      [A-Z0-9]*             # Only catch first 8 chars
                      \s+
                   )?
                   ([A-Z0-9]{3})            # 3 letter mnemonic
                   (?:\.[A-Z0-9]+)?         # Throw away postfix mod if there is any
                   \s+
                   ([^,]+)                  # A operand
                   \s*,\s*                  # , delimited
                   ([^,]+)                  # B operand
                 /xi)
    {
        my ($label, $instr, $a_op, $b_op) = ($1, $2, $3, $4);

        # Log label
        if ($label) {
            $labels{$label} = $codeline;
            say "L: $label = $codeline";
        }
        $codeline++;

        push (@code, $code);
    }
    # Match a constant
    elsif ($code =~ /^
                     ([A-Z0-9]{0,8})        # Label necessary
                     [A-Z0-9]*              # Only catch first 8 chars
                     \s+
                     equ                    # Constant instr mnemonic
                     \s+
                     ([-+*\/A-Z0-9\s+]+)    # Definition
                    /xi)
    {
        push (@code, $code);
    }
    # Match end
    elsif ($code =~ /^\s*end/) {
        last;
    }
    else {
        die "Syntax error.";
    }
}

# We'll incr in the beginning but we still want to start with 0
$codeline = -1;

for my $code (@code) {

    # Match up a line of redcode
    if ($code =~ /^(?:
                      ([A-Z0-9]{0,8})?      # Label, not necessary
                      [A-Z0-9]*             # Only catch first 8 chars
                      \s+
                   )?
                   ([A-Z0-9]{3})            # 3 letter mnemonic
                   (?:\.[A-Z0-9]+)?         # Throw away postfix mod if there is any
                   \s+
                   ([^,]+)                  # A operand
                   \s*,\s*                  # , delimited
                   ([^,]+)                  # B operand
                 /xi)
    {
        my ($label, $instr, $a_op, $b_op) = ($1, $2, $3, $4);

        $codeline++; # Not doing anything here atm though

        # TODO should produce object code or something later
        my %types = (
            '#' => "immediate",
            '@' => "indirect",
            '<' => "pre-decrement",
        );

        # Default
        #my $a_mod = "direct";
        #my $b_mod = "direct";

        my $a_mod = "";
        my $b_mod = "";

        # Fetch adress modes
        if ($a_op =~ /^([#@<])(.*)/) {
            my ($op, $rest) = ($1, $2);

            #$a_mod = $types{$op};
            $a_mod = $op;
            $a_op = $rest;
        }

        if ($b_op =~ /^([#@<])(.*)/) {
            my ($op, $rest) = ($1, $2);

            #$b_mod = $types{$op};
            $b_mod = $op;
            $b_op = $rest;
        }

        my $a_val = evaluate $a_op, $codeline;
        my $b_val = evaluate $b_op, $codeline;

        say "I: $instr $a_mod $b_mod $a_val $b_val";
    }
    # Match a constant
    elsif ($code =~ /^
                     ([A-Z0-9]{0,8})        # Label necessary
                     [A-Z0-9]*              # Only catch first 8 chars
                     \s+
                     equ                    # Constant instr mnemonic
                     \s+
                     ([-+*\/A-Z0-9\s+]+)    # Definition
                    /xi)
    {
        my ($label, $def) = ($1, $2);

        # Evaluate
        my $value = evaluate $def, $codeline;

        # And insert
        $constants{$label} = $value;

        say "L: $label = $def ($value)";
    }
    # Match end
    elsif ($code =~ /^\s*end/) {
        last;
    }
    else {
        die "Syntax error.";
    }
}

sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

