#!/usr/bin/perl -w

use utf8;
use autodie;

use Modern::Perl;
use Getopt::Long;

# Command line options
my $help;
my $verbose;
my $debug;
my $obj_out = "";
my $raw;

GetOptions(
    'help|h' => \$help,
    'obj|o=s' => \$obj_out,
    'verbose|v' => \$verbose,
    'debug' => \$debug,
    'raw|r' => \$raw,
);

my $src = $ARGV[0];

if ($help || !$src || (!$debug && !$verbose && !$raw && !$obj_out)) {
    my ($name) = $0 =~ /([^\/]+$)/;

    say "Simple assembler";
    say "  usage:";
    say "   $name [option]... [file]";
    say "  options:";
    say "   -h --help       Show this screen.";
    say "   -o --obj=FILE   Generate binary file output.";
    say "   -v --verbose    Verbose output signals in a human readable format.";
    say "   -r --raw        Outputs raw binary data.";
    exit;
}

our %labels;
our %constants;

# Evaluate an operator statement, like val*2+1
sub evaluate {
    my ($def, $linenum) = @_;

    my @pieces = split /[-+*\/]/, $def;

    for my $piece (@pieces) {

        # Remove whitespace
        $piece = trim ($piece);

        # Ignore empty and all numbers
        next if $piece =~ /^\d*$/;

        # Read a label
        if ($piece =~ /^([A-Z0-9]{0,8})[A-Z0-9]*$/i) {
            my $label = $1;

            if (exists $labels{$label}) {

                # Substitute the label with it's value
                #$def =~ s/$piece/$labels{$label}/;

                # Addresses to labels are relative to the line of code
                my $relative = $labels{$label} - $linenum;
                $def =~ s/$piece/$relative/;
            }
            elsif (exists $constants{$label}) {

                # Substitute the label with it's value
                $def =~ s/$piece/$constants{$label}/;
            }
            else {
                die "Compile error, no label '$label' in scope.";
            }
        }
        else {
            die "Syntax error, label expected ner '$piece'";
        }
    }

    my $value = eval $def;
    die "Error: Malformed operator '$def' $@" if $@;

    return $value;
}

my $codeline = 0;

open my $in, '<', $src;

my $out;
if ($obj_out) {
    open $out, '>', $obj_out;
    binmode $out;
}

# Store line of code here when processing
my @code;

while (my $line = <$in>) {
    chomp $line;

    # Ignore empty lines
    next if $line =~ /^\s*$/;

    # Remove comments, will always match
    my ($code, $comment) = $line =~ /^([^;]*);?(.*)/;

    # Don't parse a full comment line
    next if !$code;

    # Match up a line of redcode
    if ($code =~ /^(?:
                      ([A-Z0-9]{0,8})?      # Label, not necessary
                      [A-Z0-9]*             # Only catch first 8 chars
                      \s+
                   )?
                   ([A-Z0-9]{3})            # 3 letter mnemonic
                   (?:\.[A-Z0-9]+)?         # Throw away postfix mod if there is any
                   \s+
                   ([^,]+)                  # A operand
                   \s*,\s*                  # , delimited
                   ([^,]+)                  # B operand
                 /xi)
    {
        my ($label, $instr, $a_op, $b_op) = ($1, $2, $3, $4);

        # Log label
        if ($label) {
            $labels{$label} = $codeline;
            say "L: $label = $codeline" if $debug;
        }
        $codeline++;

        push (@code, $code);
    }
    # Match a constant
    elsif ($code =~ /^
                     ([A-Z0-9]{0,8})        # Label necessary
                     [A-Z0-9]*              # Only catch first 8 chars
                     \s+
                     equ                    # Constant instr mnemonic
                     \s+
                     ([-+*\/A-Z0-9\s+]+)    # Definition
                    /xi)
    {
        push (@code, $code);
    }
    # Match end
    elsif ($code =~ /^\s*end/) {
        last;
    }
    else {
        die "Syntax error.";
    }
}

# We'll incr in the beginning but we still want to start with 0
$codeline = -1;

for my $code (@code) {

    # Match up a line of redcode
    if ($code =~ /^(?:
                      ([A-Z0-9]{0,8})?      # Label, not necessary
                      [A-Z0-9]*             # Only catch first 8 chars
                      \s+
                   )?
                   ([A-Z0-9]{3})            # 3 letter mnemonic
                   (?:\.[A-Z0-9]+)?         # Throw away postfix mod if there is any
                   \s+
                   ([^,]+)                  # A operand
                   \s*,\s*                  # , delimited
                   ([^,]+)                  # B operand
                 /xi)
    {
        my ($label, $instr, $a_op, $b_op) = ($1, $2, $3, $4);

        $codeline++; # Not doing anything here atm though

        my %types = (
            '#' => "00",    # Immediate
            '@' => "10",    # Indirect
            '<' => "11",    # Pre-decrement indirect
        );

        # Default
        my $a_mod = "01";   # Direct
        my $b_mod = "01";

        my $a_type = "";
        my $b_type = "";

        # Fetch adress modes
        if ($a_op =~ /^([#@<])(.*)/) {
            my ($op, $rest) = ($1, $2);

            $a_mod = $types{$op};
            $a_type = $op;
            $a_op = $rest;
        }
        if ($b_op =~ /^([#@<])(.*)/) {
            my ($op, $rest) = ($1, $2);

            $b_mod = $types{$op};
            $b_type = $op;
            $b_op = $rest;
        }

        my $a_val = evaluate $a_op, $codeline;
        my $b_val = evaluate $b_op, $codeline;

        my $a_bin = dec2bin ($a_val, 16);
        my $b_bin = dec2bin ($b_val, 16);

        my %instr_codes = (
            DAT => '0000',
            MOV => '0001',
            ADD => '0010',
            SUB => '0011',
            JMP => '0100',
            JMPZ=> '0101',
            JMN => '0110',
            CMP => '0111',
            SLT => '1000',
            DJN => '1001',
            SPL => '1010',
        );

        die "Instr '$instr' does not exist!" if !exists $instr_codes{uc($instr)};

        my $instr_code = $instr_codes{uc($instr)};

        # Output
        if ($debug) {
            say "I: $instr $a_mod $b_mod $a_val $b_val";
        }

        if ($raw) {
            say "$instr_code$a_mod$b_mod$a_bin$b_bin";
        }
        elsif ($verbose) {
            # Ugly hack to truncate hex
            my $ophex = substr (bin2hex ($instr_code), 0, 1);
            my $modhex = substr (bin2hex ($a_mod.$b_mod), 0, 1);

            my $ahex = bin2hex ($a_bin);
            my $bhex = bin2hex ($b_bin);

            say "$instr_code $a_mod $b_mod $a_bin $b_bin   $ophex$modhex "
            . substr ($ahex, 0, 2) ." ". substr ($ahex, 2) ." "
            . substr ($bhex, 0, 2) ." ". substr ($bhex, 2)
            . "  ; $instr $a_type $a_op($a_val) $b_type $b_op($b_val)";
        }

        if ($obj_out) {
            my $what = "$instr_code$a_mod$b_mod$a_bin$b_bin";
            my $val = pack ("B40", $what);
            print $out $val;
        }
    }
    # Match a constant
    elsif ($code =~ /^
                     ([A-Z0-9]{0,8})        # Label necessary
                     [A-Z0-9]*              # Only catch first 8 chars
                     \s+
                     equ                    # Constant instr mnemonic
                     \s+
                     ([-+*\/A-Z0-9\s+]+)    # Definition
                    /xi)
    {
        my ($label, $def) = ($1, $2);

        # Evaluate
        my $value = evaluate $def, $codeline;

        # And insert
        $constants{$label} = $value;

        say "C: $label = $def ($value)" if $debug;
    }
    # Match end
    elsif ($code =~ /^\s*end/) {
        last;
    }
    else {
        die "Syntax error.";
    }
}


if ($obj_out) {
    close $out;
    my $size = (stat $obj_out)[7];
    say "Wrote $size bytes to $obj_out";
}

sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}
# With a specified length
sub dec2bin {
    my ($dec, $l) = @_;
    my $bin = unpack("B32", pack("N", $dec));

    # Force to length
    if (length($bin) < $l) {
        $bin = '0' x ($l - length($bin)) . $bin;
    }
    elsif (length($bin) > $l) {
        # Truncate from the back so 00 1111 1111 -> 1111 1111
        $bin = substr $bin, -$l;
    }

    return $bin;
}
sub dec2hex {
    my $d = shift;
    my $h = sprintf ("%x", $d);
    return $h;
}
sub hex2bin {
    my $h = shift;
    my $hlen = length($h);
    my $blen = $hlen * 4;
    return unpack("B$blen", pack("H$hlen", $h));
}
sub bin2hex {
    my $b = shift;
    return unpack("H*", pack("B*", $b));
}

