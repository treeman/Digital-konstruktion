Teori RS232

Vårt FPGA kort har en USB till RS232 port. Vi använde denna för att föra över den assemblerade spelarkoden till kortet. En överförning inleds av en startbit, därefter följer 8 databitar och en stoppbit. Hastigheten mäts i baud, tecken (på 8 bitar) per sekund. I vårt fall var ledningen hög när ingen överförning var igång (1). Överförningen inleds med att ledningen jordas (2), därefter följer 8 databitar i vald hastighet (3). I slutet av överförningen kommer en stoppbit som är hög (4). Se figur 3.

[rs232.psd]

Figur 3. En RS232 överförning.

Man har ingen gemensam klocka utan överför endast data, sändaren och mottagaren känner dock till vilken baud rate man överför med. I vårt fall använder vi 115 200 baud.

----------------------------------------------------------------------

Minnet

Vi valde att använda en core size(1) Storlek på spelplan på 8192 rader, detta brukar vara standard i duell spel men ibland avrundar man till 8000 rader. Om man kör fler än 2 spelare brukar minnet vara betyderlig större, vi ska dock endast ha 2 spelare stöd. Vi behöver enligt (1) 13 bitar för att kunna adressera hela detta område. Då minnet i FPGAN är indelade i block mindre än detta fick vi dela upp minnet på flera block.

(1) log2(8192) = 13

Varje rad Redcode delades upp i 4 delar; instruktion och adresseringsmoder 8 bitar, operand A 13 bitar, operand B 13 bitar och 8 bitar RGB färgning. Det som bäst stämde överens med vår uppdelning var att använda minnesblock utav storleken 1024 x 16 bitar (de 3 sista bitarna används ej dock i operandminnena).

[memory_cell.dia]
Figur 1 Operandminnen

De tre mest signifikanta bitarna styr multiplexern och ser till att rätt minne skriver och läses ifrån. Våra minnen var lite bättre än vad vi först förväntade oss, därför har vi en adress_sync och data_sync register, vi skulle kunna ta bort dessa och därmed snabba upp datorn vid minnesaccess.

Då vi har olika färg beroende på vilken instruktion vi har i minnet var det naturligt att slå samman instruktionsminnet och färgminnet då båda var på 8 bitar. Den resulterande maskinen ses i figur 2. Skillnaden mellan den och operandminnena är att den använder ett dualportminne med den andra adressingången kopplad till GPUn. Färgen skrivs automatiskt till minnet när man skriver in en instruktion i minnet.

[memory_cell_dual.dia]
Figur 2. Instruktions och färgminne

----------------------------------------------------------------------


* UART (+fbart?)

Vår dator använder en 13 bitars buss, det skulle därmed vara trevligt om indatat ifrån vår värddator skulle vara i detta med. Då vi använder Anders Nilssons FBART vilken arbetar i 8 bitar skulle det vara trevligt att slå samman två sändningar till en. Det gör vi med modulen i figur 43434. Modulen väntar på en data begäran, tar emot två 8 bitars överförningar, slår samman dem till 13 bitar (den kastar iväg 3 bitar) och signalerar att data finns.

[uart.dia]
Figur 324234. UART controll circuit. Slår samman två FBART överförningar till en 16 bits överförning

Vi fick även ändra i FBARTen då den gick på en 25 Mhz klocka och vårt bygga kör på 100 Mhz. Vi behövde endast öka antalet bitar i en räknade och ändra på en konstant.

----------------------------------------------------------------------


 * FIFO

Då en spelare kan ha flera olika processer igång behöver vi ett sätt att lagra alla programräknare. Vi har implementerat två stycken ”first in first out” köer i vår hårdvara, se figur 999.

[player FIFO.dia]
Figur 999. Player FIFOs.

Headregistret pekar på den översta programräknaren och tailregistret pekar på en sista. När man begär nästa programräknare ökas den nuvarande spelarens head och den översta PCn skrivs till current_pc_out. När man skriver in en PC kollas först att den nuvarande spelars kö ej är full, om den ej är full skrivs PC in och tailregistret ökas annars görs ingenting. Om någon spelares kö är tom, dvs. headregistret är lika med tailsregistret så signaleras game_over. Man kan även byta aktiv spelare.


5. Mjukvara

Det är en hel vetenskap att skriva effektiva redcode warriors och vi har endast skrapat på ytan. Vi har dock lyckats programmera ett antal exempel warriors som demonstrerar de vanligaste strategierna och olika blandningar mellan dem. 


Factory Bomber
Factory bomber (eller bomber factory då den bygger bombers) formaterar hela minnet via att masskopiera en massa ’little bombers’ till minnet. Dessa databombar minnet och kommer efter ett tag bomba isär orginalkoden. Denna warrior är därmed en blandning mellan en bombare och en replicator och en bombare.

Imp Spawner
Denna warrior är ej offensiv och har som stategi att skapar en massa imps. Imp spawner fungerar ungefär som factory bomber fast har en annan payload.

Vampire Bomber Gate Replicator

Denna otympliga warrior startade som ett skämt då vi ville se vad som hände om man inkluderade så många strategier som möjligt i en warrior. Dock blev den inte så dålig som vi trodde. Först så skapar warriors en kopia av sig själv, denna kopia kan dock ej kopiera sig själv, något som borde kunna lösas med hjälp av lite hjärnverksamhet och en texteditor. Efter kopiatorn så har warriorn en ”bomber cage”, dessa två rader databombar minnet bakåt. Efter cagen kommer vampyrkoden. En vampyr JMP bombar minnet i hopp om att fienden skall hoppa in i dess cage. Den kan därmed sno klockcykler ifrån motståndarens kod. Sist finns en gate ifall resten av koden skulle bli överkörd av en imp.

Kopimi

[KOPIMI]

Denna warrior scannar minnet efter information, kopierar den och börjar sen exekvera den. Den kan därmed härma en fientlig warrior om den skulle hitta den. Fungerar skapligt trots att den utvecklades mest för att se vad som hände om man skulle tolka Det Missionerande Kopimistsamfundet missionsbudskap; ”Kopiera och sprid”. Denna warrior använder replicator stategin.

Inseminator

Ännu en warrior som skapades på skoj men som visade sig vara rätt så effektiv. Den letar upp motståndarens kod och injicerar en massa processer i den i hopp om att motståndaren ej ska förstöra sig egna kod. Detta brukar dock förstöra funktionaliteten i motståndarens kod då den förutsätter oftast att koden exekveras sekventiellt.


